---
title: "Protogarrote - Vignette"
author: "Georg Heinze"
date: "27 11 2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This document introduces the `protogarrote` functions to analyse proteomics data and explains their use.
The following functions are available:

* `protogarrote` ... fits  a linear or logistic model with proteomics and clinical predictor variable. May include an interaction of a variable with the proteomics. Uses internal validation to determine the best values of lambda1 and lambda2.
* `coefficients.protogarrote` ... shows the estimated coefficients at the optimal lambda1, lambda2
* `predict.protogarrote` ... predicts outcomes using a `protogarrote` object and new data
* `plot.coefficients.protogarrote` ... shows the estimated coefficients for the proteomics by means of a plot and a table.

## Data set

To illustrate the use, we first generate a data set synthetically:

```{r}
source("code.R")

# first a data set
set.seed(123)

n<-300 ### sample size
k<-100 ### number of proteomics (filtered)

prop.nonzero<-runif(k,0.1,1)   # proportion nonzero for each peptide
prop.nonzero<-sort(prop.nonzero)
means.peptide<-4+prop.nonzero*10    # we create consonant peptides only

peptide <- matrix(rnorm(n*k), n, k, byrow=TRUE)+matrix(means.peptide, n, k, byrow=TRUE)

#plot(1:k, apply(peptide, 2, mean))

peptide <- peptide * rbinom(n*k, size=1, prob=matrix(prop.nonzero, n, k, byrow=TRUE))
# boxplot(peptide)   # only for small k!
```


```{r}
# clinical variables
age <- floor(runif(n, 20, 81))
sex <- rbinom(n, size=1, prob=0.5)

# outcomes

# eGFR model: define 10 random peptides, each has a delta of 1 and a beta of 1; others not relevant
predictive <- sample(1:k, size=10)


eGFR <- apply(peptide[,predictive],1,sum) + apply((peptide[,predictive]>1),1,sum) + age/10 + sex + rnorm(n, mean=-20, sd=6)
eGFR[eGFR<15] <- 15
hist(eGFR)
```

Next, we generate x and d components of the peptides. Crucial to save the means of the x's for later application of a model!

```{r}
x <- peptide
d <- (peptide != 0)*1
xmeans <- apply(x, 2, FUN=function(x) mean(x[x!=0]))
for(j in 1:k) x[,j][d[,j]==0] <- xmeans[j]
```


Now we glue everything into a data frame:

```{r}
dataset <- data.frame(log2eGFR = log2(eGFR), age=age, sex=sex, x=x, d=d)
```


We fit the 'oracle' model: as if we knew (from an oracle) which peptides are truly prognostic. This model serves as a benchmark; it will be hard to outperform it:

```{r}
# true model on data set
## true formula
formel <- as.formula(paste("eGFR ~ age + sex", paste0(" + x.", predictive, collapse=""), paste0(" + d.", predictive, collapse="")))

fit.oracle <- lm(data=dataset, formula=formel)
summary(fit.oracle)


```

Now we add a synthetic binary HF variable, which is generated by some peptides that interact with eGFR:

```{r}
# we assume that these peptides are important to generate HF (together with eGFR)
pred.hf <- sample(1:k, size=10)
pred.hf
```

For simplicity, we assume that their effect is as follows:
* for the first 5 predictive x: -0.1 + x*log2eGFR*0.1 (negative for the second 5)
* for the first 5 predictive d: -0.1 + d*log2eGFR*0.1 (negative for the second 5)
* for age: just 0.01

```{r}
x.pred <- apply(x[,pred.hf[1:5]],1,sum) - apply(x[,pred.hf[6:10]],1,sum)
d.pred <- apply(d[,pred.hf[1:5]],1,sum) - apply(d[,pred.hf[6:10]],1,sum)

linpred.hf <- -x.pred*0.1  + 0.1*x.pred*dataset$log2eGFR - 0.1*d.pred + 0.1*d.pred*dataset$log2eGFR + dataset$age*0.01
linpred.hf <- linpred.hf-mean(linpred.hf) # we subtract the mean to get approx 50% HF
phf <- plogis(linpred.hf)
dataset$hf <- rbinom(length(phf), 1, phf)
mean(dataset$hf)
```
Let us fit a simple clinical model with just age, sex and log2eGFR:

```{r}
fit.clin.hf<-glm(data=dataset, hf~age+sex+log2eGFR, family="binomial")
summary(fit.clin.hf)
```


## Linear model without interactions


Creating the data object:

the data object should consist of a list with

* x: the log2 peptide itensities, with zeros replaced by conditional means
* d: binary indicators if intensity > 0
* clinical: matrix of clinical covariates
* y: outcome variable

```{r}
x <- as.matrix(dataset[, paste0("x.", 1:k,sep="")])
d <- as.matrix(dataset[, paste0("d.", 1:k,sep="")])
age <- dataset$age
sex <- dataset$sex
log2eGFR <- dataset$log2eGFR

data.obj<-list(x=x, d=d, clinical=cbind(age, sex), y=log2eGFR)
```

Fitting the model with 11 values for lambda1 and 11 values for lambda2. The model will first generate the values for lambda1, and for each lambda1 generate a new sequence of lambda2 values. These lambda2 values are then stored in a matrix with one row for each lambda1 value. The rownames of the matrix are the values for lambda 1. The `outer` option just repeates the cross-validation to get variability out. The `cv` value determines how many 'folds' are generated in the cross-validation.

```{r}
#fit.simple <- lm(data.obj$y~data.obj$x+data.obj$d+data.obj$clinical)
fit <- protogarrote(data.obj, family="gaussian", cv=10, outer=2, nlambda=c(11,11))
```

Let's first look at the fitted values, and compare them to the original outcomes:

```{r}
library(ggplot2)
ggplot(NULL, aes(fit$fit$fitted.values, log2eGFR))+geom_point()+geom_smooth()+geom_abline(intercept=0, slope=1)
```


The apparent R-square:

```{r}
cor(fit$fit$fitted.values, log2eGFR)^2
```

Compared to the cross-validated R-squares:

```{r}
fit$cv.rsquare
```

One can 'plot' the object, meaning the cross-validated prediction error (expected squared difference between cross-validated fitted values and observed values of the outcome). Here each line correspond to a sequence of lambda1 values, and the different lambda2 values are the 'inner' loop. The vertical bars refer to standard errors of the prediction errors. The optimal combination of lambda1 and lambda2 is highlighted in black. One can also see 'which lambda2' was chosen:

```{r}
plot.protogarrote(fit)
```

The lambda values can be accessed. The row labels are the values of lambda1. The values in the matrix are the corresponding values of lambda2, which usually are very similar for a given lambda1.

```{r}
fit$lambda
```


Let's have a look at the optimal coefficients:

```{r}
plot.coefficients.protogarrote(fit, order="d")
```

## Linear model with penalty factors

Now let's prioritize those variables that have fewer zero values. We define the penalty (1= high penalty, 0=no penalty) for the peptides as follows:

```{r}
prop.nonzero<-apply(d,2,mean)
penalties <- (1-(prop.nonzero/2))**2
plot(prop.nonzero, penalties, ylim=c(0,1))
```

Now refit the linear model. The penalties are defined for all variables, i.e., for the x, the d, and the two clinical variables (which get no penalty):

```{r}
fit2 <- protogarrote(data.obj, family="gaussian", cv=10, outer=2, nlambda=c(11,11), penalties=c(penalties, penalties, 0,0))
```

Let's have a look at the coefficients:

```{r}
plot.coefficients.protogarrote(fit, order="d")
```



## Logistic model without interactions

The logistic model could be first fit without any interactions, using hf as the outcome variable. Be sure to define the penalties object correctly!

```{r}
x <- as.matrix(dataset[, paste0("x.", 1:k,sep="")])
d <- as.matrix(dataset[, paste0("d.", 1:k,sep="")])
age <- dataset$age
sex <- dataset$sex
log2eGFR <- dataset$log2eGFR

data.obj<-list(x=x, d=d, y=dataset$hf, clinical=cbind(age, sex, log2eGFR=dataset$log2eGFR))

fit3 <- protogarrote(data.obj, family="binomial", cv=10, outer=2, nlambda=c(11,11), penalties=c(penalties, penalties, 0,0,0))

```


Quick check: fitted values against true outcome status:

```{r}
boxplot(plogis(fit3$fit$fitted.values)~dataset$hf, ylim=c(0,1))
```

Let us check the r-squared:

```{r}
fit3$cv.rsquare
```

and plot the cross-validation:

```{r}
plot.protogarrote(fit3)
```

Let's check the coefficients:

```{r}
plot.coefficients.protogarrote(fit3)
```

In fact, not many proteomics were selected.

```{r}
betas<-coefficients.protogarrote(fit3)
(betas.hot<-betas[betas!=0])
```


## Logistic model with interactions

Now we fit the most advanced model: the logistic model for HF with interactions with log2eGFR. The mean and SD of log2eGFR are approximately 5.8 and 0.5, respectively. We also submit these to the protogarrote function as it will be helpful for numerical stability and interpretation of coefficients.

The four blocks of variables are: x, d, x$\times$log2eGFR, and d$\times$log2eGFR. For the interactions, log2eGFR is standardized with the center and scaling parameters submitted to the function. log2eGFR itself is internally added to the clinical variables. 

It is crucial that there are always variables with 0 penalty factor, otherwise the program may have an error in the cross-validation, as all betas might be penalized to 0 then. Anyway, it is always good to not penalize the clinical variables. We define the penalty factors for the four blocks of proteomics variables (x, d, x$\times$log2eGFR, and d$\times$log2eGFR) and for the clinical variables. Despite the clinical variables get a penalty factor of 0, this penalty factor only applies to the first, ridge, stage. At the second, garrote, stage, they can as well be shrunken to zero.



```{r}
data.obj<-list(x=x, d=d, y=dataset$hf, clinical=cbind(age, sex), interaction.x=log2eGFR)

fit4 <- protogarrote(data.obj, center.interaction.x=5.8, scale.interaction.x=0.5, family="binomial", 
                     penalties=c(penalties, penalties, penalties,penalties,0,0,0))
```

We first plot the object:

```{r}
plot.protogarrote(fit4)
```


And we plot the apparent predictions vs. the true status:

```{r}
boxplot(fit4$fit$fitted.values~ dataset$hf)
```

Now let's see the coefficients for the proteomics:

```{r}
(pcp<-plot.coefficients.protogarrote(fit4, order="d"))
pcp$selected

# these were the peptides used to generate the HF data:
sort(predictive)
```
Let us check the apparent calibration:

```{r}
pfit4<-predict.protogarrote(fit4, newdata=data.obj, type="response")
ggplot(NULL, aes(pfit4, dataset$hf))+geom_point()+geom_smooth()+geom_abline(intercept=0, slope=1)

etafit4<-predict.protogarrote(fit4, newdata=data.obj, type="link")
summary(calibfit4<-glm(dataset$hf~etafit4, family="binomial"))
```

The calibration slope is `r coef(calibfit4)[2]` which seems to point at underfit -> strong shrinkage.


